<!DOCTYPE html>
<html lang="en">
	<head>
		 
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-23296419-22"></script>
		<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'UA-23296419-22');
		</script>
		 

		<title>C++ rvalue references and move semantics for beginners - Internal Pointers</title>

		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="Monocasual Laboratories">
		<meta name="description" content="A collection of personal notes and thoughts on rvalue references, their role in move semantics and how they can significantly increase the performance of your applications.">
		<meta name="keywords" content="C++,rvalue,move semantics,RVO,rvalue references,C++11">
		<meta name="copyright" content="2015-2024 Monocasual Laboratories">
		<meta name="application-name" content="Internal Pointers">
		<meta name="google-site-verification" content="d6wzhBnnEXNHg7kty5SNXVBKd4e29wUFP69SROd-3eI" />

		<meta property="og:title" content="C++ rvalue references and move semantics for beginners" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" />
<meta property="og:image" content="https://www.internalpointers.com/img/internalpointers-card.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="900" />
<meta property="og:site_name" content="Internal Pointers" />
<meta property="og:description" content="A collection of personal notes and thoughts on rvalue references, their role in move semantics and how they can significantly increase the performance of your applications." />
<meta name="twitter:card" content="summary" />
<meta name="twitter:url" content="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" />
<meta name="twitter:title" content="C++ rvalue references and move semantics for beginners" />
<meta name="twitter:description" content="A collection of personal notes and thoughts on rvalue references, their role in move semantics and how they can significantly increase the performance of your applications." />
<meta name="twitter:image" content="https://www.internalpointers.com/img/internalpointers-card.png" />

		<link rel="icon" href="/img/favicon.ico">
		<link rel="apple-touch-icon-precomposed" href="/img/favicon-152.png">
		<link rel="stylesheet" href="/main-1.4.0.css">

		<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/monokai-sublime.min.css">
		
		<script defer src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
		<script defer src="//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
		<script defer src="/main-1.4.0.js"></script>

		
<script defer src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
	hljs.initHighlighting();
});
</script>

	</head>
	<body>
		<div class="ip-follow-us-popup">

    <div class="ip-follow-us-popup__side">
        <img src="/img/facebook-like-thumb.svg" alt="Like it!">
    </div>

    <div class="ip-follow-us-popup__header">
        <p>Join us on Facebook!</p>
    </div>

    <div class="ip-follow-us-popup__body">
        <div class="ip-follow-us-popup__body__ok">
        <img src="/img/facebook-like-thumb.svg" alt="Like it!">
        </div>
    </div>

    <div class="ip-follow-us-popup__footer">
        <div><a href="#" class="ip-follow-us-popup__footer__nope">Nope, thanks anyway.</a></div>
    </div>

</div>		<div class="ip-cookie-banner">
    <div class="ip-container">
        <p>We use cookies to personalise content and ads, to provide social media features and to analyse our traffic. By using our site, you acknowledge that you have read and understand our <a href="{{ url('/privacy/') }}">Privacy Policy</a>, and our <a href="{{ url('/tos/') }}">Terms of Service</a>. Your use of this site is subject to these policies and terms. | <a href="#" class="ip-cookie-banner__close">ok, got it</a></p>
    </div>
</div>		<div class="ip-header">
	<div class="ip-container">
		<div class="ip-header__logo">
			<a href="/">**internal / pointers</a>
		</div>
		<div class="ip-header__links">
			<ul>
				<li><a href="/rss">rss</a></li>
				<li><a href="/about">about</a></li>
			</ul>
		</div>
	</div>
</div>

<div class="ip-sub-header">
</div>
		<div class="ip-body">

	<div class="ip-container">

		<div class="ip-post">

			<div class="ip-post__info">
				<p>— Written by Triangles on June 02, 2018 
								• updated on February 15, 2019  
								• ID 63 —</p>
			</div>

			<div class="ip-post__title">
				<h1>C++ rvalue references and move semantics for beginners</h1>
			</div>

			<div class="ip-post__intro">
				<p>A collection of personal notes and thoughts on rvalue references, their role in move semantics and how they can significantly increase the performance of your applications.</p>
			</div>

			
			<div class="ip-post__body">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- internalpointers responsive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-1778432007040046"
     data-ad-slot="1269254897"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>In my previous article <a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c">Understanding the meaning of lvalues and rvalues in C++</a> I had the chance to explain to myself the logic behind <em>rvalues</em>. The core idea is that in C++ you will find such temporary, short-lived values that you cannot alter in any way.</p>
<p>Surprisingly, modern C++ (C++0x and greater) has introduced <strong>rvalue references</strong>: a new type that can bind to temporary objects, giving you the ability to modify them. Why?</p>
<p>Let's begin this journey with a little brush up of temporary values:</p>
<pre><code class="lang-c++">int x = 666;                    // (1)
int y = x + 5;                  // (2)

std::string s1 = &quot;hello &quot;;
std::string s2 = &quot;world&quot;;
std::string s3 = s1 + s2;       // (3)

std::string getString() {
  return &quot;hello world&quot;;
}
std::string s4 = getString();   // (4)
</code></pre>
<p>On line (1) the literal constant <code>666</code> is an rvalue: it has no specific memory address, except for some temporary register while the program is running. It needs to be stored in a lvalue (<code>x</code>) to be useful. Line (4) is similar, but here the rvalue is not hard-coded, rather it is being returned by the function <code>getString()</code>. However, as in line (1), the temporary object must be stored in an lvalue (<code>s4</code>) to be meaningful.</p>
<p>Lines (2) and (3) seem more subtle: the compiler has to create a temporary object to hold the result of the <code>+</code> operator. Being a temporary one, the output is of course an rvalue that must be stored somewhere. And that's what I did by putting the results in <code>y</code> and <code>s3</code> respectively.</p>
<h2>Introducing the magic of rvalue references</h2>
<p>The traditional C++ rules say that you are allowed to take the address of an rvalue only if you store it in a <strong>const</strong> (immutable) variable. More technically, <em>you are allowed to bind a const lvalue to an rvalue</em>. Consider the following example:</p>
<pre><code class="lang-c++">int&amp; x = 666;       // Error
const int&amp; x = 666; // OK
</code></pre>
<p>The first operation is wrong: it's an invalid initialization of non-const reference of type <code>int&amp;</code> from an rvalue of type <code>int</code>. The second line is the way to go. Of course, being <code>x</code> a constant, you can't alter it.</p>
<p>C++0x has introduced a new type called <strong>rvalue reference</strong>, denoted by placing a double ampersand <code>&amp;&amp;</code> after some type. Such rvalue reference lets you modify the value of a temporary object: it's like removing the <code>const</code> attribute in the second line above!</p>
<p>Let's play a bit with this new toy:</p>
<pre><code class="lang-c++">  std::string   s1     = &quot;Hello &quot;;
  std::string   s2     = &quot;world&quot;;
  std::string&amp;&amp; s_rref = s1 + s2;    // the result of s1 + s2 is an rvalue
  s_rref += &quot;, my friend&quot;;           // I can change the temporary string!
  std::cout &lt;&lt; s_rref &lt;&lt; &#39;\n&#39;;       // prints &quot;Hello world, my friend&quot;
</code></pre>
<p>Here I create two simple strings <code>s1</code> and <code>s2</code>. I join them and I put the result (a temporary string, i.e. an rvalue) into <code>std::string&amp;&amp; s_rref</code>. Now <code>s_rref</code> is a reference to a temporary object, or an rvalue reference. There are no <code>const</code> around it, so I'm free to modify the temporary string to my needs. This wouldn't be possible without rvalue references and its double ampersand notation. To better distinguish it, we refer to traditional C++ references (the single-ampersand one) as <strong>lvalue references</strong>.</p>
<p>This might seem useless at a first glance. However rvalue references pave the way for the implementation of <strong>move semantics</strong>, a technique which can significantly increase the performance of your applications.</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- internalpointers responsive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-1778432007040046"
     data-ad-slot="1269254897"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2>Move semantics, the scenic route</h2>
<p>Move semantics is a new way of moving resources around in an optimal way by avoiding unnecessary copies of temporary objects, based on rvalue references. In my opinion, the best way to understand what move semantics is about is to build a wrapper class around a <em>dynamic resource</em> (i.e. a dynamically allocated pointer) and keep track of it as it moves in and out functions. Keep in mind however that move semantics does not apply only to classes!</p>
<p>That said, let's take a look at the following example:</p>
<pre><code class="lang-c++">class Holder
{
  public:

    Holder(int size)         // Constructor
    {
      m_data = new int[size];
      m_size = size;
    }

    ~Holder()                // Destructor
    {
      delete[] m_data;
    }

  private:

    int*   m_data;
    size_t m_size;
};
</code></pre>
<p>It is a naive class that handles a dynamic chunk of memory: nothing fancy so far, except for the allocation part. When you choose to manage the memory yourself you should follow the so-called <a href="https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29">Rule of Three</a>. This rule states that if your class defines one or more of the following methods it should probably explicitly define all three:</p>
<ul>
<li>destructor;</li>
<li>copy constructor;</li>
<li>copy assignment operator.</li>
</ul>
<p>A C++ compiler will generate them by default if needed, in addition to the constructor and other functions we don't care about right now. Unfortunately the default versions are just "not enough" when your class deals with dynamic resources. Indeed, the compiler couldn't generate a constructor like the one in the example above: it doesn't know anything about the logic of our class.</p>
<h3>Implementing the copy constructor</h3>
<p>Let's stick to the Rule of Three and implement the copy constructor first. As you may know, the copy constructor is used to create a <em>new</em> object from another <em>existing</em> object. For example:</p>
<pre><code class="lang-c++">Holder h1(10000); // regular constructor
Holder h2 = h1;   // copy constructor
Holder h3(h1);    // copy constructor (alternate syntax)
</code></pre>
<p>How a copy constructor would look like:</p>
<pre><code class="lang-c++">Holder(const Holder&amp; other)
{
  m_data = new int[other.m_size];  // (1)
  std::copy(other.m_data, other.m_data + other.m_size, m_data);  // (2)
  m_size = other.m_size;
}
</code></pre>
<p>Here I'm initializing a new <code>Holder</code> object out of the existing one passed in as <code>other</code>: I create a new array of the same size (1) and then I copy the actual data from <code>other.m_data</code> to <code>m_data</code> (i.e. <code>this.m_data</code>) (2).</p>
<h3>Implementing the assignment operator</h3>
<p>It's now time for the assignment operator, used to replace an <em>existing</em> object with another <em>existing</em> object. For example:</p>
<pre><code class="lang-c++">Holder h1(10000);  // regular constructor
Holder h2(60000);  // regular constructor
h1 = h2;           // assignment operator
</code></pre>
<p>How an assigment operator would look like:</p>
<pre><code class="lang-c++">Holder&amp; operator=(const Holder&amp; other) 
{
  if(this == &amp;other) return *this;  // (1)
  delete[] m_data;  // (2)
  m_data = new int[other.m_size];
  std::copy(other.m_data, other.m_data + other.m_size, m_data);
  m_size = other.m_size;
  return *this;  // (3)
}
</code></pre>
<p>First of all a little protection against self-assignment (1). Then, since we are replacing the content of this class with another one, let's wipe out the current data (2). What's left is just the same code we wrote in the copy constructor. By convention a reference to this class is returned (3).</p>
<p>The key point of the copy constructor and the assignment operator is that they both receive a <code>const</code> reference to an object in input and make <em>a copy</em> out of it for the class they belong to. The object in input, being a constant reference, is of course left untouched.</p>
<h2>The limitations of our current class design</h2>
<p>Our class is good to go, but it lacks of some serious optimization. Consider the following function:</p>
<pre><code class="lang-c++">Holder createHolder(int size)
{
  return Holder(size);
}
</code></pre>
<p>It returns a <code>Holder</code> object <em>by value</em>. We know that when a function returns an object by value, the compiler has to create a temporary — yet fully-fledged — object (rvalue). Now, our <code>Holder</code> is a heavy-weight object due to its internal memory allocation, which is a very expensive task: returning such things by value with our current class design would trigger multiple expensive memory allocations, which is rarely a great idea. How come? Consider this:</p>
<pre><code class="lang-c++">int main()
{
  Holder h = createHolder(1000);
}
</code></pre>
<p>A temporary object coming out from <code>createHolder()</code> is passed to the copy constructor. According to our current design, the copy constructor allocates its own <code>m_data</code> pointer by <em>copying</em> the data from the temporary object. Two expensive memory allocations: a) during the creation of the temporary, b) during the actual object copy-construct operation.</p>
<p>The same <em>copy</em> procedure occurs within the assignment operator:</p>
<pre><code class="lang-c++">int main()
{
  Holder h = createHolder(1000); // Copy constructor
  h = createHolder(500);         // Assignment operator
}
</code></pre>
<p>The code inside our assignment operator wipes the memory out and then reallocates it from scratch by <em>copying</em> the data from the temporary object. Yet another two expensive memory allocations: a) during the creation of the temporary, b) in the actual object assignment operator.</p>
<p>Too many expensive copies! We already have a fully-fledged object, the temporary and short-lived one returning from <code>createHolder()</code>, built for us by the compiler: it's an rvalue that will fade away with no use at the next instruction: why, during the construction/assignment stages, don't we <em>steal</em> — or <em>move</em> the allocated data inside the temporary object instead of making an expensive copy out of it?</p>
<p>In the old days of C++ there was no way to optimize this out: returning heavy-weight objects by value was simply a no-go. Fortunately in C++11 and greater we are allowed (and encouraged) to do this, by improving our current <code>Holder</code> class with move semantics. In a nutshell, we will steal existing data from temporary objects instead of making useless clones. Don't copy, just <em>move</em>, because moving is always cheaper.</p>
<h2>Implementing move semantics with rvalue references</h2>
<p>Let's spice up our class with move semantics: the idea is to add new versions of the copy constructor and assignment operator so that they can take a temporary object in input to <em>steal</em> data from. To steal data means to modify the object the data belongs to: how can we modify a temporary object? By using rvalue references!</p>
<p>At this point we naturally follow another C++ pattern called the <a href="https://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29#Rule_of_Five">Rule of Five</a>. It's an extension to the Rule of Three seen before and it states that any class for which move semantics are desirable, has to declare two additional member functions:</p>
<ul>
<li>the <strong>move constructor</strong> — to construct <em>new</em> objects by stealing data from temporaries;</li>
<li>the <strong>move assignment operator</strong> — to replace <em>existing</em> objects by stealing data from temporaries. </li>
</ul>
<h3>Implementing the move constructor</h3>
<p>A typical move constructor:</p>
<pre><code class="lang-c++">Holder(Holder&amp;&amp; other)     // &lt;-- rvalue reference in input
{
  m_data = other.m_data;   // (1)
  m_size = other.m_size;
  other.m_data = nullptr;  // (2)
  other.m_size = 0;
}
</code></pre>
<p>It takes in input an rvalue reference to another <code>Holder</code> object. This is the key part: being an rvalue reference, we can modify it. So let's steal its data first (1), then set it to null (2). No deep copies here, we have just moved resources around! It's important to set the rvalue reference data to some valid state (2) to prevent it from being accidentally deleted when the temporary object dies: our <code>Holder</code> destructor calls <code>delete[] m_data</code>, remember? In general, for reasons that will become more clear in a few paragraphs, it's a good idea to always leave the objects being stolen from in some well-defined state.</p>
<h3>Implementing the move assignment operator</h3>
<p>The move assignment operator follows the same logic:</p>
<pre><code class="lang-c++">Holder&amp; operator=(Holder&amp;&amp; other)     // &lt;-- rvalue reference in input  
{  
  if (this == &amp;other) return *this;

  delete[] m_data;         // (1)

  m_data = other.m_data;   // (2)
  m_size = other.m_size;

  other.m_data = nullptr;  // (3)
  other.m_size = 0;

  return *this;
}
</code></pre>
<p>We steal data (2) from the other object coming in as an rvalue reference, after a cleanup of the existing resources (1). Let's not forget to put the temporary object to some valid state (3) as we did in the move constructor. Everything else is just regular assignment operator duty.</p>
<p>Now that we have our new methods in place, the compiler is smart enough to detect whether you are creating an object with a temporary value (rvalue) or a regular one (lvalue) and trigger the proper constructor/operator accordingly. For example:</p>
<pre><code class="lang-c++">int main()
{
  Holder h1(1000);                // regular constructor
  Holder h2(h1);                  // copy constructor (lvalue in input)
  Holder h3 = createHolder(2000); // move constructor (rvalue in input) (1) 

  h2 = h3;                        // assignment operator (lvalue in input)
  h2 = createHolder(500);         // move assignment operator (rvalue in input)
}
</code></pre>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- internalpointers responsive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-1778432007040046"
     data-ad-slot="1269254897"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2>Where and when move semantics apply</h2>
<p>Move semantics provide a smarter way of passing heavy-weight things around. You create your heavy-weight resource only once and then you move it where needed in a natural way. As I said before, move semantics is not only about classes. You can make use of it whenever you need to change the ownership of a resource across multiple areas of your application. However keep in mind that, unlike a pointer, you are not sharing anything: if object A steals data from object B, data in object B no longer exists, thus is no longer valid. As we know this is not a problem when dealing with temporary objects, but you can also steal from regular ones. We will see how shortly.</p>
<h3>I tried your code: the move constructor never gets called!</h3>
<p>That's right. If you run the last snippet above you will notice how the move constructor does not get called during (1). The regular constructor is called instead: this is due to a trick called <strong>Return Value Optimization (RVO)</strong>. Modern compilers are able to detect that you are returning an object by value, and they apply a sort of return shortcut to avoid useless copies.</p>
<p>You can tell the compiler to bypass such optimization: for example, GCC supports the <code>-fno-elide-constructors</code> flag. Compile the program with such flag enabled and run it again: the amount of constructor/destructor calls will increase noticeably.</p>
<h3>Why should I care implementing move semantics if the RVO does its optimization job by default?</h3>
<p>RVO is only about return values (output), not function parameters (input). There are many places where you may pass movable objects as input parameters, which would make the move constructor and the move assignment operator come into play, if implemented. The most important one: the Standard Library. During the upgrade to C++11 all the algorithms and containers in there were extended to support move semantics. So if you use the Standard Library with classes that follow the Rule of Five you will gain an important optimization boost.</p>
<h2>Can I move lvalues?</h2>
<p>Yes you can, with the utility function <code>std::move</code> from the Standard Library. It is used to convert an lvalue into an rvalue. Say we want to steal from an lvalue:</p>
<pre><code class="lang-c++">int main()
{
  Holder h1(1000);     // h1 is an lvalue
  Holder h2(h1);       // copy-constructor invoked (because of lvalue in input)
}
</code></pre>
<p>This will not work: since <code>h2</code> receives an lvalue in input, the copy constructor is being triggered. We need to force the move constructor on <code>h2</code> in order to make it steal from <code>h1</code>, so:</p>
<pre><code class="lang-c++">int main()
{
  Holder h1(1000);           // h1 is an lvalue
  Holder h2(std::move(h1));  // move-constructor invoked (because of rvalue in input)
}
</code></pre>
<p>Here <code>std::move</code> has converted the lvalue <code>h1</code> into an rvalue: the compiler sees such rvalue in input and then triggers the move constructor on <code>h2</code>. The object <code>h2</code> will steal data from <code>h1</code> during its construction stage.</p>
<p>Mind that at this point <code>h1</code> is a <em>hollow</em> object. However, we did a good thing when in our move constructor we set the stolen object's data to a valid state (<code>other.m_data = nullptr</code>, remember?). Now you may want to reuse <code>h1</code>, test it in some way or let it go out of scope without causing nasty crashes.</p>
<h2>Final notes and possible improvements</h2>
<p>This article is way too long and I've only scratched the surface of move semantics. What follows is a quick list of additional concepts I will further investigate in the future.</p>
<h3>We did RAII in our basic <code>Holder</code> example</h3>
<p><strong>Resource Acquisition Is Initialization (RAII)</strong> is a C++ technique where you wrap a class around a <em>resource</em> (file, socket, database connection, allocated memory, ...). The resource is initialized in the class constructor and cleaned up in the class destructor. This way you are sure to avoid resource leaks. More information: <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">here</a>.</p>
<h3>Mark you move constructors and move assignment operators with <code>noexcept</code></h3>
<p>The C++11 keyword <code>noexcept</code> means "this function will never throw exceptions". It is used to optimize things out. Some people say that move constructors and move assignment operators should never throw. Rationale: you should not allocate memory or call other code in there. You should only copy data and set the other object to null, i.e. non-throwing operations. More information: <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f6-if-your-function-may-not-throw-declare-it-noexcept">here</a>, <a href="https://stackoverflow.com/questions/9249781/are-move-constructors-required-to-be-noexcept">here</a>.</p>
<h3>Further optimizations and stronger exception safety with copy-and-swap idiom</h3>
<p>All the constructors/assignment operators in the <code>Holder</code> class are full of duplicate code, which is not so great. Moreover, if the allocation throws an exception in the copy assignment operator the source object might be left in a bad state. The <strong>copy-and-swap idiom</strong> fixes both issues, at the cost of adding a new method to the class. More information: <a href="https://stackoverflow.com/a/3279550/3296421">here</a>, <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Copy-and-swap">here</a>.</p>
<h3>Perfect forwarding</h3>
<p>This technique allows you to move your data across multiple template and non-template functions without wrong type conversions (i.e. perfectly). More information: <a href="https://stackoverflow.com/a/3582313/3296421">here</a>, <a href="https://www.justsoftwaresolutions.co.uk/cplusplus/rvalue_references_and_perfect_forwarding.html">here</a>.</p>
<h2>Sources</h2>
<p>Stack Overflow - <em>When is an rvalue evaluated?</em> (<a href="https://stackoverflow.com/questions/44298456/when-is-an-rvalue-evaluated">link</a>)<br>
Mikw's C++11 blog - <em>Lesso #5: Move Semantics</em> (<a href="https://www.google.it/amp/s/mbevin.wordpress.com/2012/11/20/move-semantics/amp/">link</a>)<br>
Artima - <em>A Brief Introduction to Rvalue References</em> (<a href="https://www.artima.com/cppsource/rvalue.html">link</a>)<br>
Stack Overflow - <em>C++11 rvalues and move semantics confusion (return statement)</em> (<a href="https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement/4986802#4986802">link</a>)<br>
Cpp-patterns - <em>The rule of five</em> (<a href="https://cpppatterns.com/patterns/rule-of-five.html">link</a>)<br>
open-std.org - <em>A Brief Introduction to Rvalue References</em> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#rvalue_reference">link</a>)<br>
Microsoft - <em>Rvalue Reference Declarator: &amp;&amp;</em> (<a href="https://docs.microsoft.com/en-us/cpp/cpp/rvalue-reference-declarator-amp-amp">link</a>)<br>
Wikipedia - <em>Rule of three (C++ programming)</em> (<a href="https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29">link</a>)<br>
Stack Overflow - <em>What are all the member-functions created by compiler for a class? Does that happen all the time?</em> (<a href="https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap">link</a>)<br>
cplusplus.com - <em>Copy constructors, assignment operators, and exception safe assignment</em> (<a href="http://www.cplusplus.com/articles/y8hv0pDG/">link</a>)<br>
Stack Overflow - <em>What is the copy-and-swap idiom?</em> (<a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">link</a>)<br>
Wikipedia - <em>Assignment operator (C++)</em> (<a href="https://en.wikipedia.org/wiki/Assignment_operator_%28C%2B%2B%29">link</a>)<br>
Stack Overflow - <em>When the move constructor is actually called if we have (N)RVO?</em> (<a href="https://stackoverflow.com/questions/50007475/when-the-move-constructor-is-actually-called-if-we-have-nrvo/50007581#50007581">link</a>)<br>
cppreference.com - <em>The rule of three/five/zero</em> (<a href="http://en.cppreference.com/w/cpp/language/rule_of_three">link</a>)<br>
cprogramming.com - <em>Move semantics and rvalue references in C++11</em> (<a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">link</a>)<br>
Stack Overflow - <em>What is std::move(), and when should it be used?</em> (<a href="https://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used">link</a>)</p>			</div>


			<div class="ip-post__tags">
								<a class="ip-tag" href="/tag/c">C++</a>
				 • 								<a class="ip-tag" href="/tag/rvalue">rvalue</a>
				 • 								<a class="ip-tag" href="/tag/move-semantics">move semantics</a>
				 • 								<a class="ip-tag" href="/tag/rvo">RVO</a>
				 • 								<a class="ip-tag" href="/tag/rvalue-references">rvalue references</a>
				 • 								<a class="ip-tag" href="/tag/c-11">C++11</a>
											</div>

			<div class="ip-post__neighbor-posts">
								
							</div>
			
						<div class="ip-post__comments">
				<div class="ip-post__comments__title">
					comments
				</div>
				
								<div class="ip-post__comments__list">
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">James</span> on 
							<span class="date">June 11, 2018 at 06:59</span>
						</div> 
						<div class="body">Nice article that helps convey the reasoning behind this new feature in an easy to understand way. Minor bug in the the move assignment operator's self-assignment check: Should be ==. I'd also suggest that zero'ing out m_size in addition to nulling out the m_data pointer would help reinforce the idea of keeping the object in a valid state post-move.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Jeremy</span> on 
							<span class="date">June 11, 2018 at 07:08</span>
						</div> 
						<div class="body">This was a really excellent write up. I look forward to reading your walk throughs of the other topics mentioned. Great work!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">▲s</span> on 
							<span class="date">June 11, 2018 at 22:01</span>
						</div> 
						<div class="body">Thanks @James for your hints, article updated!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">▲s</span> on 
							<span class="date">June 11, 2018 at 22:02</span>
						</div> 
						<div class="body">@Jeremy thank you for your kind words <3</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Wassili</span> on 
							<span class="date">June 19, 2018 at 16:05</span>
						</div> 
						<div class="body">good article, but "Perfect forwarding" works only with templates</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Johan</span> on 
							<span class="date">June 20, 2018 at 13:45</span>
						</div> 
						<div class="body">The text says "Now s_rref is a reference to a temporary object, or an rvalue reference."<br />
<br />
I think it's important to understand that a named rvalue reference is actually a lvalue. This can be a bit confusing at first.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">ubiratans</span> on 
							<span class="date">June 21, 2018 at 15:29</span>
						</div> 
						<div class="body">Very good and interesting article! Congrats!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">aka</span> on 
							<span class="date">November 19, 2018 at 00:26</span>
						</div> 
						<div class="body">Very good article. thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">mtanh</span> on 
							<span class="date">November 25, 2018 at 08:41</span>
						</div> 
						<div class="body">Great article. Thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Artyom</span> on 
							<span class="date">December 13, 2018 at 13:46</span>
						</div> 
						<div class="body">Thanks a lot for crisp explanations.<br />
When I'm trying to explain or write similar examples, for preventing RVO, I often add a simple if-condition. Usually it breaks RVO and makes things clearer.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">akis</span> on 
							<span class="date">February 14, 2019 at 09:59</span>
						</div> 
						<div class="body">Thank you very much for taking the effort to explain this difficult concept. I am looking forward for your next topics</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Daniel</span> on 
							<span class="date">February 17, 2019 at 21:28</span>
						</div> 
						<div class="body">Thanks! The kind of explanation that makes me happy to read.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">wj</span> on 
							<span class="date">February 17, 2019 at 22:50</span>
						</div> 
						<div class="body">You are a scholar, sir!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">xyz</span> on 
							<span class="date">February 22, 2019 at 21:10</span>
						</div> 
						<div class="body">thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">RP</span> on 
							<span class="date">March 14, 2019 at 08:38</span>
						</div> 
						<div class="body">Great article! <br />
I am wondering about one thing: suppose having a class holding  dynamic (via pointer) as well as ?static? (non ptr) resources. For dynamic resources I understand that copying the pointer is fine, but this only works for pointers or integral types, right? Suppose I have a bigger chunk of data stored in a data member DATA_, would I have to perform DATA_ = std::move(other.DATA_) instead of DATA_ = other.DATA_ ? Because, basically, even if we are dealing with an rvalue reference, the data members are still lvalues, right? This also got way to long. Anyway, thanks for this awesome blog. Keep up the great work!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">vaibhav</span> on 
							<span class="date">March 24, 2019 at 14:04</span>
						</div> 
						<div class="body">Awsome , I was trying hard with such type of explanation on move , great work.....thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">fhabermacher</span> on 
							<span class="date">March 25, 2019 at 12:44</span>
						</div> 
						<div class="body">Thank you, really useful description!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Maigo</span> on 
							<span class="date">April 05, 2019 at 07:31</span>
						</div> 
						<div class="body">This is the best article I've read on rvalue references and move semantics! It keeps the basic simple, and leaves more advanced topics (e.g. return value optimization, copy-and-swap idiom, perfect forwarding) to the end!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Garfield</span> on 
							<span class="date">April 24, 2019 at 18:50</span>
						</div> 
						<div class="body">Thanks! perfect explaination!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Sameh Hassanein</span> on 
							<span class="date">May 02, 2019 at 20:41</span>
						</div> 
						<div class="body">Excellent Work Thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">malviyanshiv</span> on 
							<span class="date">May 07, 2019 at 15:03</span>
						</div> 
						<div class="body">Great article ...helped a lot</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Kailasa Marathe</span> on 
							<span class="date">May 12, 2019 at 18:25</span>
						</div> 
						<div class="body">Very helpful. Hope to see more on other topics too.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Carlos Reyes</span> on 
							<span class="date">May 29, 2019 at 02:02</span>
						</div> 
						<div class="body">The C++ standard says that a compiler has to implement the return value optimization (RVO) when possible. At least one of your examples of bad code would actually be optimized into efficient code. In fact, move semantics are not as useful as appears at first glance because of compiler optimizations. Compilers were already pretty good at optimizing away redundant data copies in many cases.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Misha</span> on 
							<span class="date">June 15, 2019 at 13:11</span>
						</div> 
						<div class="body">In Holder createHolder(int size) copy constructor won't be called.<br />
<br />
To have it called I had to allocate Holder* with new and return *h.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Enes Hecan</span> on 
							<span class="date">June 16, 2019 at 11:16</span>
						</div> 
						<div class="body">You are good teacher sir!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Wasin</span> on 
							<span class="date">July 08, 2019 at 04:50</span>
						</div> 
						<div class="body">Hey good article! I learned a ton with this.<br />
<br />
To add a thing on top.<br />
I use g++ (7.4.0) on Linux, and it optimizes away having to create a temporary variable thus avoid calling copy constructor completely. I have to add -fno-elide-constructors to force it to call it.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">César</span> on 
							<span class="date">July 26, 2019 at 16:08</span>
						</div> 
						<div class="body">Great article! One comment though.<br />
<br />
I've followed the coded to the dot and when<br />
<br />
Holder h3 = createHolder(2000);<br />
<br />
is executed, oddly enough only the regular constructor is invoked! I did then<br />
<br />
Holder h3 = std::move(createHolder(2000));<br />
<br />
and then the regular and move constructor were called, as expected. Do you now why?<br />
<br />
Thanks for sharing! It is really appreciated :)</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Triangles</span> on 
							<span class="date">August 03, 2019 at 10:48</span>
						</div> 
						<div class="body">@César, it is likely that your compiler is performing some clever optimizations. Take a look at the paragraph "I tried your code: the move constructor never gets called!", it's the RVO in action!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Sarah</span> on 
							<span class="date">October 24, 2019 at 09:43</span>
						</div> 
						<div class="body">Hi, the example to show the use of T&& with strings does not seem the best to me. Indeed when doing "string s = s1 + s2", you can also use "s+= "my friend". So there is no need to use string&& in that particular example. Am I wrong?</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Triangles</span> on 
							<span class="date">October 27, 2019 at 10:31</span>
						</div> 
						<div class="body">@Sarah sure, you can also use "s += ..." when doing "string s = s1 + s2". However the string&& version shows you that you can alter the value of a temporary (where the temporary is the result of s1 + s2).</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">baixiangcpp</span> on 
							<span class="date">November 06, 2019 at 10:33</span>
						</div> 
						<div class="body">very good article.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Yue</span> on 
							<span class="date">November 27, 2019 at 07:32</span>
						</div> 
						<div class="body">Great writing. Thank you!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Dsonophorus</span> on 
							<span class="date">December 15, 2019 at 01:24</span>
						</div> 
						<div class="body">Thanks, very clean presentation of a detailed and important topic!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">mindentropy</span> on 
							<span class="date">December 21, 2019 at 05:22</span>
						</div> 
						<div class="body">I am assuming you do not do null check in the destructor because delete is harmless on a nullptr. So  when the temporary object goes out of scope the destructor gets called and there would be delete on the nullptr with no problems.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Rajesh Kumar</span> on 
							<span class="date">January 15, 2020 at 10:57</span>
						</div> 
						<div class="body">Excellent piece of article...Thank you...!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Siddhartha Agarwal</span> on 
							<span class="date">January 23, 2020 at 00:15</span>
						</div> 
						<div class="body">Very nicely explained. Enjoyed reading</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">pye</span> on 
							<span class="date">February 02, 2020 at 08:31</span>
						</div> 
						<div class="body">Great article!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Yujie</span> on 
							<span class="date">February 06, 2020 at 17:27</span>
						</div> 
						<div class="body">Great thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">ZZ</span> on 
							<span class="date">March 15, 2020 at 06:12</span>
						</div> 
						<div class="body">The best teaching material ever! </div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">RAII</span> on 
							<span class="date">April 04, 2020 at 12:29</span>
						</div> 
						<div class="body">Thanx for this awsome writeup! We appreciate your work !! :)</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">craseeedoood</span> on 
							<span class="date">April 17, 2020 at 09:10</span>
						</div> 
						<div class="body">This and the article on lvalues/rvalues were incredibly lucid and effective explanations, better than any resource I could find. Thank you so much man!!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">samira</span> on 
							<span class="date">May 17, 2020 at 17:35</span>
						</div> 
						<div class="body">"More technically, you are allowed to bind a const lvalue to an rvalue. "<br />
Shouldn't the sentence above is rewritten as following:<br />
"More technically, you are allowed to bind a const rvalue to an lvalue. "</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Mahmud</span> on 
							<span class="date">June 05, 2020 at 13:44</span>
						</div> 
						<div class="body">This is one of the best article to understand 'rvalue & std::move' currently out there. Very well written and easy to understand for beginners, I wish I could find this earlier. <br />
<br />
Thank you so very much :)</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">MJS</span> on 
							<span class="date">June 20, 2020 at 04:26</span>
						</div> 
						<div class="body">Really informative article and makes what can be a hard concept to understand (especially if reading the spec)  easy to grok. </div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">URZq</span> on 
							<span class="date">June 30, 2020 at 14:52</span>
						</div> 
						<div class="body">After reading "effective modern c++" a few years ago, I needed a refresher for a job interview. This article was exactly what I needed, thank you.<br />
<br />
The mention of perfect forwarding triggered some PTSD. Does anyone use that in the real world ? :D<br />
<br />
</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Alexpanda</span> on 
							<span class="date">July 08, 2020 at 05:20</span>
						</div> 
						<div class="body">Great article, well-explained! Thank you!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Jaswant</span> on 
							<span class="date">July 08, 2020 at 10:43</span>
						</div> 
						<div class="body">Perfect explanation! Thank you very much! :)</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Amarghosh</span> on 
							<span class="date">October 20, 2020 at 12:53</span>
						</div> 
						<div class="body">I googled for ELI5 std::move and it eventually took me here. Thanks for explaining it in an easy to understand way with examples. Appreciate the effort.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">andy_li</span> on 
							<span class="date">January 02, 2021 at 17:42</span>
						</div> 
						<div class="body">This is a really really useful article, thank you.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Tarun_K</span> on 
							<span class="date">January 05, 2021 at 18:09</span>
						</div> 
						<div class="body">Thank you so much. Explained in very simple way and clearly</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">SuperKint</span> on 
							<span class="date">February 06, 2021 at 07:42</span>
						</div> 
						<div class="body">Wonderful c++Practice.  Thanks for ariticle</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">HypertextAssassin0273</span> on 
							<span class="date">February 25, 2021 at 07:28</span>
						</div> 
						<div class="body">Well Explained!!!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">David</span> on 
							<span class="date">February 25, 2021 at 19:51</span>
						</div> 
						<div class="body">Wow, this is a BEAST. Very easy to understand, but also thorough enough that doesn't miss out any detail. I was pleasantly surprised you mentioned the GCC compiler thing :) This article should be the official introduction guide to Move Semantics for any beginner, easily outshines any other articles out there. I really enjoyed reading it and the "journey" :))</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Heavynest</span> on 
							<span class="date">March 07, 2021 at 22:01</span>
						</div> 
						<div class="body">Nice post. Thanks</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Koder</span> on 
							<span class="date">March 27, 2021 at 14:59</span>
						</div> 
						<div class="body">Great article, well explained!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">idnsunset</span> on 
							<span class="date">May 08, 2021 at 10:05</span>
						</div> 
						<div class="body">Very clear step-by-step explanation for where and why that rvalue reference comes. It saved me from reading those tedious and obscure articles.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Tony</span> on 
							<span class="date">May 19, 2021 at 22:13</span>
						</div> 
						<div class="body">I learned so much, thank you!!!!! <3 <3 <3 >w<</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Prantick</span> on 
							<span class="date">May 31, 2021 at 14:49</span>
						</div> 
						<div class="body">Genuinely wonderful article... clears so many rudimentary concepts. Keep up the good work!!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Mihai</span> on 
							<span class="date">September 14, 2021 at 19:42</span>
						</div> 
						<div class="body">DAMN this is very good, thank you so much!!!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">cast</span> on 
							<span class="date">September 26, 2021 at 03:15</span>
						</div> 
						<div class="body">shouldn't it be? <br />
Holder h3(std::move(createHolder(2000)));<br />
to invoke a move construct from a rvalue:</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">HanChen</span> on 
							<span class="date">November 21, 2021 at 00:52</span>
						</div> 
						<div class="body">This is an excellent tutorial, thanks so much!<br />
There is another great explanation:<br />
https://stackoverflow.com/questions/37935393/pass-by-value-vs-pass-by-rvalue-reference/37956725</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Ivan Bilicki</span> on 
							<span class="date">December 05, 2021 at 17:59</span>
						</div> 
						<div class="body">This is a great article, thank you! Just one comment.<br />
"RVO is only about return values (output), not function parameters (input). There are many places where you may pass movable objects as input parameters, which would make the move constructor and the move assignment operator come into play, if implemented."<br />
An example of this would be really helpful.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Amulya</span> on 
							<span class="date">March 09, 2022 at 11:41</span>
						</div> 
						<div class="body">Thank you for such an amazing article. You made the concepts so clear!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">wawa</span> on 
							<span class="date">April 14, 2022 at 04:23</span>
						</div> 
						<div class="body">Thank you for your explanation!!! :)</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Robert Pawlak</span> on 
							<span class="date">June 03, 2022 at 13:14</span>
						</div> 
						<div class="body">"The C++11 keyword noexcept means "this function will never throw exceptions" "<br />
<br />
No, it means: if function will throw exception then behaviour is undefined.<br />
Basically you can throw exception in noexcept function, but it has to be catched inside.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Robert Kent</span> on 
							<span class="date">September 01, 2022 at 03:48</span>
						</div> 
						<div class="body">Very helpful, thank you</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Andy</span> on 
							<span class="date">September 26, 2022 at 05:38</span>
						</div> 
						<div class="body">Thanks for your detail explanation! It helps me much!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Chun Hu</span> on 
							<span class="date">September 27, 2022 at 20:50</span>
						</div> 
						<div class="body">Thank you for the clear explanation!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Iman</span> on 
							<span class="date">October 14, 2022 at 17:37</span>
						</div> 
						<div class="body">Great explanation with full details.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Kent Zhang</span> on 
							<span class="date">November 05, 2022 at 14:33</span>
						</div> 
						<div class="body">Thank you for sharing! This article helps me a lot!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Nevzat</span> on 
							<span class="date">November 27, 2022 at 04:10</span>
						</div> 
						<div class="body">Thanks for the effort!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">oyiboebiye@gmail.com </span> on 
							<span class="date">January 10, 2023 at 13:43</span>
						</div> 
						<div class="body">Thanks alot for your Awesome explanation </div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">----</span> on 
							<span class="date">June 22, 2023 at 19:48</span>
						</div> 
						<div class="body">Thank you for the clear explanation!</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">Choi Myeongsu</span> on 
							<span class="date">July 08, 2023 at 14:32</span>
						</div> 
						<div class="body"><3</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">vtk</span> on 
							<span class="date">July 23, 2023 at 09:11</span>
						</div> 
						<div class="body">Awesome article. please continue your journey of writing articles in simple way. God bless you.</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">iisthphir</span> on 
							<span class="date">September 21, 2023 at 15:53</span>
						</div> 
						<div class="body">Seems rather arbitrary to make a const & bindable to an rvalue but not the same for a non const &.<br />
If your going to implicitly create a memory location for an rvalue why should that have anything to do with whether what is going to live there is a constant or not?<br />
I guess it was a choice to make the intent more visible or somesuch?</div> 
					</div>
										<div class="ip-post__comments__list__comment">
						<div class="info">
							<span class="author">GLoad</span> on 
							<span class="date">September 21, 2023 at 17:00</span>
						</div> 
						<div class="body">Awesome</div> 
					</div>
									</div>
							</div>
			
			<div class="ip-post__social-tools">
				<div class="ip-post__social-tools__title">
					share!
				</div>
				<div class="ip-post__social-tools__twitter item"></div>
			</div>

		</div>

	</div>

</div>

		<div class="ip-footer">
	<div class="ip-container">
		© 2015-2024 — Monocasual Laboratories — 
		<a href="/tos" rel="nofollow">terms of service</a> — 
		<a href="/privacy" rel="nofollow">privacy policy</a> — 
		<a href="/about">about</a> — 
		<a href="/rss">RSS feed</a>
	</div>
</div>
	</body>
</html>

